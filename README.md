# jetLite

## Relation Extraction using TensorFlow

The Relation Extraction component uses Deep Learning for inference. It employs the TensorFlow library to do the heavy-lifting. Model files are included in the repo.

There are 3 different ways of classification schemes (or relation type details) for relation extraction that are used here. First is the basic relation types, where only the 6 main ACE relation types are used (7 total with `other` class representing no relation). Then there are the subtypes, where two relations only match if their subtypes match. There are 19 total classes in this scheme (18 + `other`). The last is the subclass with ordering, where two relations only match iff their subtypes match and the relationship order is preserved. There are 37 total classes in this scheme (36 + `other`).

### Choosing a type detail
For the 3 different levels of details in classification, there are 3 enums in Java and 3 strings in Python. In Java, the detail level is given by the `TypeDetail` enum which is given when instantiating the `RelationTagger` class (see below). The accepted values are `Basic`, `Subtype`, and `SubtypeWithOrder`, which correspond to 7, 19, and 37 classes. A similar selection can be done in Python with the `relation_detail` variable, with the values `basic`, `subtype`, and `subtype_with_order` respectively.

### Using the component
Compile all the files using the included `compile` script and run the tester using the `Rtrain` script (which no longer does training). In order to use the component from elsewhere, you will need to instantiate the `RelationTagger` class as
```
RelationTagger(config, true, typeDetail)
```
where `config` is a `Properties` object and `typeDetail` is an enum of type `TypeDetail` as explained above. Note that you need to have the respective model file in your `RTFmodel` folder (see Training the network to generate models not included in the release).

### Installing TensorFlow
See [how to install TF](https://www.tensorflow.org/install/) and [how to install TF for Java](https://www.tensorflow.org/install/install_java) for installation instructions. The `jni` folder described in the second link should be placed in the root folder and be referenced as a library in your runtime script using `-Djava.library.path=./jni`. This repo comes with Tensorflow 1.3.0. For future releases, update the TF library in the `lib` folder, and the `compile` and `Rtrain` scripts to match your TF version.

### Additional Data Files
The project as a whole is missing the ACE files, which are available through [LDC](https://catalog.ldc.upenn.edu/LDC2005T09). They should be placed under the `data` directory. The other requirement (right now) is the GloVe pretrained word embeddings file, which can be found on the [Stanford NLP's GloVe website](https://nlp.stanford.edu/projects/glove/). It should also be placed under the `data` directory. They might in future be integrated into the model files themselves.

### Training the network
In case you want to train the network yourself, you can use the included `network.py` file in the `RTFmodel` folder. For that you will need the training files, which can be generated by the `RelationTagger` class if you uncomment the `rtagger.getExamples` calls in the `main` method. Make sure you instantiate the `RelationTagger` with the correct type detail. The program will generate two files, which will need to be moved into the `RTFmodel` folder and renamed into `trainingc.txt` and `testc.txt`, where `c` is the number of classes used (see above). From there, run the Python script using `python network.py` and the model file will be created for you.